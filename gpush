#!/bin/bash

set -euo pipefail
IFS=

push () { var="$1"; eval "${var}[\${#${var}[@]}]=\"\$2\""; }

help () {
    echo "usage: "
    echo "  gpush [options] remote(s) [options]"
    echo
    echo "  Pushes the currently active branch to all the remotes,"
    echo "  prepending the local hostname and underscore to the branch"
    echo "  name on the remote side."
    echo
    echo "  Meant for pushing to repositories with working directories,"
    echo "  which is my most common usage nowadays. Might extend to work"
    echo "  with proper remotes, too, for safety?"
    echo
    echo "  Remotes in the repo in the current directory:"
    echo "  `git remote | tr '\n' ' '`"
    exit 1
}

if [ $# -eq 0 ]; then
    help
fi

if [ "$1" = "-h" -o "$1" = "--help" ]; then
    help
fi


hn=`hostname`
br=`cj-git-current-branch`


declare -a remotes
declare -a opts
opts_has_values=0

for v in "$@"; do
    if echo "$v" | egrep -q '^-'; then
	push opts "$v"
	opts_has_values=1
    else
	push remotes "$v"
    fi
done

gpush () {
    # heh odd, turn this on here, how will it behave in the for loop? 
    # Accept it?
    set -x

    # Bash is shit. Can't dereference an empty array while also using
    # set -eu.
    if [ "$opts_has_values" = 1 ]; then
	git push "${opts[@]}" "$1" "$br:${hn}_$br"
    else
	git push "$1" "$br:${hn}_$br"
    fi
}

for remote in "${remotes[@]}"; do
    gpush "$remote"
done

