#!/usr/bin/perl -w

# Wed 24 Jul 08:37:09 BST 2019
(my $email='ch%christianjaeger,ch')=~ tr/%,/@./;

use strict; use warnings FATAL => 'uninitialized';

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname timedesc

  Uses Perl's https://metacpan.org/pod/Time::ParseDate plus custom
  features (s, m, h, d, y shortcuts for seconds, minutes, .. years) to
  parse timedesc, which can be a duration or a point in time, and
  sleeps till then. Prints the end time to STDERR unless --quiet is
  given.

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
our $opt_quiet;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   "quiet"=> \$opt_quiet,
	   ) or exit 1;
usage unless @ARGV==1;

my ($str)= @ARGV;

use Time::ParseDate;
use Time::HiRes qw(time sleep);

my %short2long=
  (s=> "seconds",
   m=> "minutes",
   h=> "hours",
   d=> "days",
   y=> "years",
   "'"=> "minutes",
   "''"=> "seconds",
  );

sub parseFuture ($$;$);
sub parseFuture ($$;$){
    my ($orig, $now, $accept_past)= @_;
    my @parts= split /\+/, $orig;
    my $t= do {
        if (@parts > 1) {
            # must be relative!-- or not? see below
            #my @ts = map { parseFuture $_ } @parts;
            #no, fold.
            my $t= $now;
            for my $p (@parts) {
                # How to enforce it to be relative??  what about
                # "10:40+5min" or so ? Ah that actually does work and is
                # not all-parts relative! But, what about '5s+4:40'? Well
                # that's parsed as 4:40:00 currently. And, might be
                # perfect.
                $t= parseFuture($p, $t, 1);
            }
            $t
        } else {
            my $s= $orig;
            # Time::ParseDate does not support 's' etc, thus pre-process
            $s=~ s{(\b|\d)([smhdy])(\b|\d)}{
                $1 . ($short2long{$2} // die "bug") . $3
            }ge;
            $s=~ s{(\'+)}{
                ($short2long{$1} // die "bug")
            }ge;
            my ($maybe_t, $err)=
              parsedate($s,
                        WHOLE=> 1, PREFER_FUTURE=> 1, VALIDATE=> 1, UK=>1,
                        NOW=> $now);
            defined $maybe_t
              or die "parseFuture('$orig'): $err";
            $maybe_t
        }
    };
    if (!$accept_past and $t < $now) {
        die "parseFuture('$orig'): time (".localtime($t)
            ." is past now (".localtime ($now).")";
    }
    $t
}

sub sleepUntil ($) {
    my ($t)=@_;
    while (1) {
        my $now= time;
        my $d= $t-$now;
        if ($d <= 0) {
            return
        }
        #warn "sleep $d"; ah, perl already handles interrupted sleep calls?
        # well, would have to try with a signal handler.
        sleep $d
    }
}


my $t= parseFuture $str, time;

warn "$myname: sleeping till $t = ".localtime($t)."\n"
  unless $opt_quiet;

sleepUntil $t;

#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;
