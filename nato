#!/usr/bin/perl -w

# Wed Apr 30 15:33:56 BST 2014
(my $email='XXX%YYY,ch')=~ tr/%,/@./;

use strict;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname [string(s)]

  Translate string(s) to list of NATO phonetic alphabet entities.

  Read from stdin if no arguments given.

  Options:

    --practise|--training    practising mode with random strings.

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
our $opt_practise;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   "practise"=> \$opt_practise,
	   "training"=> \$opt_practise,
	   ) or exit 1;


usage "--practise doesn't take any arguments"
  if $opt_practise && @ARGV;

our $tbl=
  +{
    a=> "Alfa",
    b=> "Bravo",
    c=> "Charlie",
    d=> "Delta",
    e=> "Echo",
    f=> "Foxtrot",
    g=> "Golf",
    h=> "Hotel",
    i=> "India",
    j=> "Juliett",
    k=> "Kilo",
    l=> "Lima",
    m=> "Mike",
    n=> "November",
    o=> "Oscar",
    p=> "Papa",
    q=> "Quebec",
    r=> "Romeo",
    s=> "Sierra",
    t=> "Tango",
    u=> "Uniform",
    v=> "Victor",
    w=> "Whiskey",
    x=> "X-ray",
    y=> "Yankee",
    z=> "Zulu",
    "-"=> "Dash",
   };

sub say ($) {
    my ($str)=@_;
    my @out; my $print= sub {
        push @out, @_
    };
    my $pos=0;
    while ($str=~ m/(.)(.|$)/sgc) {
	# ALWAYS forget: can't take those from above since that would
	# break /c (get all in one huge list I guess)
	my ($c,$next)=($1,$2);
	if (defined (my $word= $$tbl{lc $c})) {
	    &$print("$word ");
	} else {
	    &$print
	      (do {
		  if ($c eq ".") {
		      if ($next and $next=~ /\S/) {
			  "Point"
		      } else {
			  "Stop"
		      }
		  } elsif ($c eq " ") {
		      ""
		  } else {
		      $c
		  }
	       },
	       " ");
	}
	pos($str)= ++$pos;
    }
    &$print("\n");
    join("", @out)
}

sub randomint ($) {
    int rand $_[0]
}

sub randomstr {
    my $all= "ABCDEFGHIJKLMNOPQRSTUVWXYZ.0123456789.";
    my $alllen= length $all;
    my $len= 1 + randomint 10;
    my @o;
    for (1..$len) {
        push @o, substr $all, randomint($alllen), 1
    }
    join("", @o)
}

sub getans {
    require Chj::IO::Command;
    my $s= Chj::IO::Command->new_sender('rlwrap', 'bash', '-c', 'set -eu; read FOO; echo "$FOO"');
    my $ans= $s->xcontent;
    $s->xfinish;
    chomp $ans;
    $ans
}

sub cleanup {
    my ($s)=@_;
    $s=~ s/\s+/ /sg;
    $s=~ s/^\s+//;
    $s=~ s/\s+\z//;
    lc $s
}

if ($opt_practise) {
    print "If you hit enter without entering anything, I will show the response.\n";
    while (1) {
        my $str= randomstr;
        print "What is the NATO translation of: $str\n";
        my $tra= say $str;
      LP: {
            my $ans= getans;
            if (not length $ans) {
                print "OK, it is: $tra\n";
            } else {
                if (cleanup ($tra) eq cleanup ($ans)) {
                    print "Correct.\n"
                } else {
                    print "Incorrect. Try again.\n";
                    redo LP;
                }
            }
        }
    }
} else {
    if (@ARGV) {
        print say $_ for @ARGV
    } else {
        while (<>) {
            print say $_
        }
    }
}

#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;
